pipeline {
    agent { 
        label 'ansible' 
    }

    environment {
        DEFAULT_REFS = 'master,main,'
    }

    stages {
        stage('Checkout Code') {
            steps {
                script {
                    if (!env.ghprbSourceBranch || !env.ghprbTargetBranch || !env.ghprbActualCommit || !env.ghprbGhRepository) {
                        error "Pull request environment variables are missing. Ensure that the build is triggered by a GitHub pull request."
                    }

                    echo "Pull Request Branch: ${env.ghprbSourceBranch}"
                    echo "Target Branch: ${env.ghprbTargetBranch}"
                    echo "Pull Request Commit: ${env.ghprbActualCommit}"
                    echo "GitHub Repository: ${env.ghprbGhRepository}"

                    def ghRepository = env.ghprbGhRepository
                    def (owner, repo) = ghRepository.tokenize('/')
                    env.GITHUB_OWNER = owner
                    env.GITHUB_REPO = repo

                    env.GIT_REPO_URL = "git@github.com:${env.GITHUB_OWNER}/${env.GITHUB_REPO}.git"

                    echo "GITHUB_OWNER: ${env.GITHUB_OWNER}"
                    echo "GITHUB_REPO: ${env.GITHUB_REPO}"
                    echo "GIT_REPO_URL: ${env.GIT_REPO_URL}"

                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: "${env.ghprbActualCommit}"]],
                        doGenerateSubmoduleConfigurations: false,
                        extensions: [
                            [$class: 'CloneOption', depth: 0, noTags: false, reference: '', shallow: false]
                        ],
                        userRemoteConfigs: [[
                            url: "${env.GIT_REPO_URL}",
                            refspec: '+refs/pull/*:refs/remotes/origin/pr/*'
                        ]]
                    ])

                    sh "git fetch origin ${env.ghprbTargetBranch}"
                }
            }
        }

        stage('Get Diff for new_qa.tfvars') {
            steps {
                sh '''
                    echo "Generating diff for new_qa.tfvars between ${ghprbTargetBranch} and the pull request commit..."
                    git diff origin/${ghprbTargetBranch}..HEAD -- new_qa.tfvars > diff.md || true

                    echo "Diff output:"
                    cat diff.md

                    echo "Extracting source changes from the diff..."
                    grep -E '^[-+][[:space:]]*source[[:space:]]*=' diff.md > source_changes.txt || true

                    echo "Content of source_changes.txt:"
                    cat source_changes.txt
                '''
            }
        }

        stage('Check for Source Changes') {
            steps {
                script {
                    def changesDetected = sh(script: 'if [ -s source_changes.txt ]; then echo "true"; else echo "false"; fi', returnStdout: true).trim()
                    if (changesDetected == "true") {
                        echo "Source changes detected"
                        env.CHANGES_DETECTED = "true"
                    } else {
                        echo "No source changes detected"
                        env.CHANGES_DETECTED = "false"
                    }
                }
            }
        }

        stage('Extract and Perform Git Diffs for Changed Modules') {
            when {
                expression { env.CHANGES_DETECTED == 'true' }
            }
            steps {
                script {
                    def sourceChanges = readFile('source_changes.txt').readLines()
                    def oldSourceMap = [:]
                    def newSourceMap = [:]

                    def extractSourceUrl = { String text ->
                        def match = text =~ /source\s*=\s*["'](.*?)["']/
                        if (match) {
                            return match[0][1]
                        }
                        return null
                    }

                    def extractRef = { String url ->
                        def refKeyword = '?ref='
                        def refIndex = url.indexOf(refKeyword)
                        if (refIndex != -1) {
                            return url.substring(refIndex + refKeyword.length())
                        }
                        return null
                    }

                    def extractRepo = { String url ->
                        if (url.startsWith('git@github.com:')) {
                            def pathPart = url.substring('git@github.com:'.length())
                            def refIndex = pathPart.indexOf('?ref=')
                            if (refIndex != -1) {
                                pathPart = pathPart.substring(0, refIndex)
                            }
                            return pathPart
                        }
                        return null
                    }

                    sourceChanges.each { line ->
                        line = line.replaceAll(/[\u0000-\u001F]/, '').trim()
                        def sign = line[0]
                        def sourceLine = line.substring(1).trim()

                        def sourceUrl = extractSourceUrl(sourceLine)
                        if (sourceUrl == null) {
                            echo "Failed to extract source URL from line: ${line}"
                            return
                        }

                        def sourceKey = sourceUrl.contains('?ref=') ? sourceUrl.substring(0, sourceUrl.indexOf('?ref=')) : sourceUrl

                        def ref = extractRef(sourceUrl)

                        if (sign == '-') {
                            oldSourceMap[sourceKey] = ref
                        } else if (sign == '+') {
                            newSourceMap[sourceKey] = ref
                        }
                    }

                    def defaultRefs = env.DEFAULT_REFS.split(',').collect { it.trim() }

                    sh 'echo "# Git Diffs for Changed Modules" > changelog.md'

                    newSourceMap.each { sourceKey, newRef ->
                        def oldRef = oldSourceMap[sourceKey]
                        if (oldRef != null) {
                            def repoUrl = sourceKey
                            def repoName = extractRepo(repoUrl)

                            if (repoName == null) {
                                echo "Unsupported or local repository URL: ${repoUrl}. Skipping."
                                return
                            }

                            echo "Processing repository: ${repoName}"
                            def repoDir = "repo_${repoName.replaceAll(/[^\w]/, '_')}"

                            def gitRepoUrl = "git@github.com:${repoName}"
                            if (!repoName.endsWith('.git')) {
                                gitRepoUrl += '.git'
                            }

                            sh """
                                rm -rf ${repoDir}
                                git clone ${gitRepoUrl} ${repoDir}
                            """
                            dir(repoDir) {
                                def determineRef = { ref ->
                                    if (ref != null) {
                                        return ref
                                    }
                                    for (def defaultRef in defaultRefs) {
                                        def refExists = sh(
                                            script: "git show-ref --verify --quiet refs/heads/${defaultRef} || git show-ref --verify --quiet refs/tags/${defaultRef}",
                                            returnStatus: true
                                        ) == 0
                                        if (refExists) {
                                            echo "Using default ref '${defaultRef}' in repository ${repoName}"
                                            return defaultRef
                                        }
                                    }
                                    echo "No default ref found in repository ${repoName}. Skipping."
                                    return null
                                }

                                oldRef = determineRef(oldRef)
                                newRef = determineRef(newRef)

                                if (oldRef == null || newRef == null) {
                                    echo "Could not determine refs for comparison. Skipping module."
                                    return
                                }

                                sh "git fetch origin ${oldRef}:${oldRef} || git fetch origin tag ${oldRef} || true"
                                sh "git fetch origin ${newRef}:${newRef} || git fetch origin tag ${newRef} || true"

                                def refExists = { ref ->
                                    return sh(
                                        script: "git show-ref --verify --quiet refs/heads/${ref} || git show-ref --verify --quiet refs/tags/${ref}",
                                        returnStatus: true
                                    ) == 0
                                }

                                if (!refExists(oldRef)) {
                                    echo "Old ref '${oldRef}' does not exist in the repository ${repoName}. Skipping."
                                    return
                                }
                                if (!refExists(newRef)) {
                                    echo "New ref '${newRef}' does not exist in the repository ${repoName}. Skipping."
                                    return
                                }

                                def changelogFile = "../changelog_${oldRef}_to_${newRef}.md"
                                sh "git diff ${oldRef} ${newRef} > ${changelogFile}"

                                sh """
                                    echo "## Changes in module from ${oldRef} to ${newRef}" >> ../changelog.md
                                    cat ${changelogFile} >> ../changelog.md
                                """
                            }
                            sh "rm -rf ${repoDir}"
                        } else {
                            echo "This is a newly added source: ${sourceKey}; no diff"
                            sh """
                                echo "## New module added: ${sourceKey}" >> changelog.md
                                echo "This is newly added; no diff." >> changelog.md
                            """
                        }
                    }

                    oldSourceMap.each { sourceKey, oldRef ->
                        if (!newSourceMap.containsKey(sourceKey)) {
                            echo "This source has been removed: ${sourceKey}"
                            sh """
                                echo "## Module removed: ${sourceKey}" >> changelog.md
                                echo "Module has been removed; no diff." >> changelog.md
                            """
                        }
                    }
                }
            }
        }

        stage('Gather comparison results') {
            when {
                expression { env.CHANGES_DETECTED == 'true' }
            }
            steps {
                script {
                    def files = findFiles(glob: 'changelog_*.md')
                    def comments = ''
                    files.each { file ->
                        def diffContent = readFile(file.path).replace('`', '\\`')
                        comments += diffContent + '\n'
                    }
                    comments = comments.trim()
                    writeFile file: 'combined_comments.md', text: comments
                }
            }
        }

        stage('Display Diffs with ANSI Colors') {
            when {
                expression { env.CHANGES_DETECTED == 'true' }
            }
            steps {
                script {
                    def files = findFiles(glob: 'changelog_*.md')
                    files.each { file ->
                        if (file.getLength() > 0) {
                            echo "Changes detected in ${file.path}:"
                            def content = readFile(file.path)
                            echo content
                        } else {
                            echo "No changes detected in ${file.path}."
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                try {
                    if (env.ghprbPullId) {
                        def changesDetected = (env.CHANGES_DETECTED == 'true')

                        withCredentials([string(credentialsId: 'github_token', variable: 'GITHUB_TOKEN')]) {
                            def ghRepository = env.ghprbGhRepository
                            def (owner, repo) = ghRepository.tokenize('/')
                            def prNumber = env.ghprbPullId

                            def apiUrl = "https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/comments"

                            if (changesDetected) {
                                def diffContent = readFile('combined_comments.md').trim()
                                def commentBody = "[BOT COMMENT]\n```diff\n${diffContent}\n```"

                                def requestBody = groovy.json.JsonOutput.toJson([body: commentBody])

                                // Fetch existing comments
                                sh """
                                    curl -s -H "Authorization: token \$GITHUB_TOKEN" -H "Content-Type: application/json" "${apiUrl}" -o comments.json
                                """
                                def commentsJson = sh(script: 'cat comments.json', returnStdout: true).trim()

                                def existingCommentUrl = sh(
                                    script: "grep -A 2 '\"body\": \"\\[BOT COMMENT\\]' comments.json | grep '\"url\":' | awk -F '\"' '{print \$4}'",
                                    returnStdout: true
                                ).trim()

                                if (existingCommentUrl) {
                                    // Update existing comment
                                    writeFile file: 'update_request.json', text: requestBody
                                    sh """
                                        curl -s -X PATCH -H "Authorization: token \$GITHUB_TOKEN" -H "Content-Type: application/json" -d @update_request.json "${existingCommentUrl}" -o /dev/null
                                    """
                                    echo "Updated existing comment."
                                } else {
                                    // Create new comment
                                    writeFile file: 'create_request.json', text: requestBody
                                    sh """
                                        curl -s -X POST -H "Authorization: token \$GITHUB_TOKEN" -H "Content-Type: application/json" -d @create_request.json "${apiUrl}" -o /dev/null
                                    """
                                    echo "Created new comment."
                                }

                                // Clean up temporary files
                                sh "rm -f comments.json update_request.json create_request.json"
                            } else {
                                echo "No source changes detected; no comment will be posted."
                            }
                        }
                    } else {
                        echo 'Not a PR build; skipping comment update.'
                    }
                } catch (Exception e) {
                    echo "An error occurred in the post section: ${e.getMessage()}"
                    // Optionally, handle the error without failing the pipeline
                }
            }
        }

        failure {
            echo 'Pipeline failed.'
        }
    }
}
